----------------------------
缓存一致性					|
----------------------------

----------------------------
场景 一						|
----------------------------
	# 先读DB,后删除缓存,缓存删除失败,导致数据不一致
		* 更新某商品的库存,当前商品的库存是100,现在要更新为99,先更新数据库更改成99,然后删除缓存,发现删除缓存失败了
		* 这意味着数据库存的是99,而缓存是100,这导致数据库和缓存不一致

	# 解决
		* 先删除缓存,然后在更新数据库,如果删除缓存失败,那就不要更新数据库
		* 如果删除缓存成功而更新数据库失败,那查询的时候只是从数据库里查了旧的数据而已,这样就能保持数据库与缓存的一致性


----------------------------
场景 二						|
----------------------------
	# 并发高的情况下
		* A线程先删除了缓存,然后更新数据库对库存进行 -1 操作,还未来得及提交修改
		* B线程读取数据,发现缓存不存在,于是尝试读取DB,检索到结果是 100,写入到缓存
		* 此时A线程提交了修改,DB的数据是99,但缓存的数据是100,导致了数据的不一致性

	# 解决方案
		* 可以用队列的去解决这个问,创建几个队列,如20个,根据商品的ID去做hash值,然后对队列个数取摸,得到队列的下标
		* 把读写请求都写入到队列里面去执行,串行化,这样就解决了数据不一致的问题,但是,性能又不好了

		* 当有数据更新请求时,先把它丢到队列里去,当更新完后在从队列里去除,如果在更新的过程中,遇到以上场景,先去缓存里看下有没有数据
		
		* 如果没有,可以先去队列里看是否有相同商品ID在做更新,如果有也把查询的请求发送到队列里去,然后同步等待缓存更新完成

		* 这里有一个优化点,如果发现队列里有一个查询请求了,那么就不要放新的查询操作进去了,用一个 while(true) 循环去查询缓存
		* 循环个200MS左右,如果缓存里还没有则直接取数据库的旧数据,一般情况下是可以取到的


	# 整复杂了不是 ? 我觉得redis 存在一些脏数据没啥,只要保证DB业务数据的一致性就好